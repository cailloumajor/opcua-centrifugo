// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package opcua

import (
	"context"
	"github.com/gopcua/opcua"
	"github.com/gopcua/opcua/ua"
	"sync"
)

// Ensure, that ClientExtDepsMock does implement ClientExtDeps.
// If this is not the case, regenerate this file with moq.
var _ ClientExtDeps = &ClientExtDepsMock{}

// ClientExtDepsMock is a mock implementation of ClientExtDeps.
//
// 	func TestSomethingThatUsesClientExtDeps(t *testing.T) {
//
// 		// make and configure a mocked ClientExtDeps
// 		mockedClientExtDeps := &ClientExtDepsMock{
// 			GetEndpointsFunc: func(ctx context.Context, endpoint string, opts ...opcua.Option) ([]*ua.EndpointDescription, error) {
// 				panic("mock out the GetEndpoints method")
// 			},
// 			NewClientFunc: func(endpoint string, opts ...opcua.Option) RawClientProvider {
// 				panic("mock out the NewClient method")
// 			},
// 			SelectEndpointFunc: func(endpoints []*ua.EndpointDescription, policy string, mode ua.MessageSecurityMode) *ua.EndpointDescription {
// 				panic("mock out the SelectEndpoint method")
// 			},
// 		}
//
// 		// use mockedClientExtDeps in code that requires ClientExtDeps
// 		// and then make assertions.
//
// 	}
type ClientExtDepsMock struct {
	// GetEndpointsFunc mocks the GetEndpoints method.
	GetEndpointsFunc func(ctx context.Context, endpoint string, opts ...opcua.Option) ([]*ua.EndpointDescription, error)

	// NewClientFunc mocks the NewClient method.
	NewClientFunc func(endpoint string, opts ...opcua.Option) RawClientProvider

	// SelectEndpointFunc mocks the SelectEndpoint method.
	SelectEndpointFunc func(endpoints []*ua.EndpointDescription, policy string, mode ua.MessageSecurityMode) *ua.EndpointDescription

	// calls tracks calls to the methods.
	calls struct {
		// GetEndpoints holds details about calls to the GetEndpoints method.
		GetEndpoints []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Endpoint is the endpoint argument value.
			Endpoint string
			// Opts is the opts argument value.
			Opts []opcua.Option
		}
		// NewClient holds details about calls to the NewClient method.
		NewClient []struct {
			// Endpoint is the endpoint argument value.
			Endpoint string
			// Opts is the opts argument value.
			Opts []opcua.Option
		}
		// SelectEndpoint holds details about calls to the SelectEndpoint method.
		SelectEndpoint []struct {
			// Endpoints is the endpoints argument value.
			Endpoints []*ua.EndpointDescription
			// Policy is the policy argument value.
			Policy string
			// Mode is the mode argument value.
			Mode ua.MessageSecurityMode
		}
	}
	lockGetEndpoints   sync.RWMutex
	lockNewClient      sync.RWMutex
	lockSelectEndpoint sync.RWMutex
}

// GetEndpoints calls GetEndpointsFunc.
func (mock *ClientExtDepsMock) GetEndpoints(ctx context.Context, endpoint string, opts ...opcua.Option) ([]*ua.EndpointDescription, error) {
	if mock.GetEndpointsFunc == nil {
		panic("ClientExtDepsMock.GetEndpointsFunc: method is nil but ClientExtDeps.GetEndpoints was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Endpoint string
		Opts     []opcua.Option
	}{
		Ctx:      ctx,
		Endpoint: endpoint,
		Opts:     opts,
	}
	mock.lockGetEndpoints.Lock()
	mock.calls.GetEndpoints = append(mock.calls.GetEndpoints, callInfo)
	mock.lockGetEndpoints.Unlock()
	return mock.GetEndpointsFunc(ctx, endpoint, opts...)
}

// GetEndpointsCalls gets all the calls that were made to GetEndpoints.
// Check the length with:
//     len(mockedClientExtDeps.GetEndpointsCalls())
func (mock *ClientExtDepsMock) GetEndpointsCalls() []struct {
	Ctx      context.Context
	Endpoint string
	Opts     []opcua.Option
} {
	var calls []struct {
		Ctx      context.Context
		Endpoint string
		Opts     []opcua.Option
	}
	mock.lockGetEndpoints.RLock()
	calls = mock.calls.GetEndpoints
	mock.lockGetEndpoints.RUnlock()
	return calls
}

// NewClient calls NewClientFunc.
func (mock *ClientExtDepsMock) NewClient(endpoint string, opts ...opcua.Option) RawClientProvider {
	if mock.NewClientFunc == nil {
		panic("ClientExtDepsMock.NewClientFunc: method is nil but ClientExtDeps.NewClient was just called")
	}
	callInfo := struct {
		Endpoint string
		Opts     []opcua.Option
	}{
		Endpoint: endpoint,
		Opts:     opts,
	}
	mock.lockNewClient.Lock()
	mock.calls.NewClient = append(mock.calls.NewClient, callInfo)
	mock.lockNewClient.Unlock()
	return mock.NewClientFunc(endpoint, opts...)
}

// NewClientCalls gets all the calls that were made to NewClient.
// Check the length with:
//     len(mockedClientExtDeps.NewClientCalls())
func (mock *ClientExtDepsMock) NewClientCalls() []struct {
	Endpoint string
	Opts     []opcua.Option
} {
	var calls []struct {
		Endpoint string
		Opts     []opcua.Option
	}
	mock.lockNewClient.RLock()
	calls = mock.calls.NewClient
	mock.lockNewClient.RUnlock()
	return calls
}

// SelectEndpoint calls SelectEndpointFunc.
func (mock *ClientExtDepsMock) SelectEndpoint(endpoints []*ua.EndpointDescription, policy string, mode ua.MessageSecurityMode) *ua.EndpointDescription {
	if mock.SelectEndpointFunc == nil {
		panic("ClientExtDepsMock.SelectEndpointFunc: method is nil but ClientExtDeps.SelectEndpoint was just called")
	}
	callInfo := struct {
		Endpoints []*ua.EndpointDescription
		Policy    string
		Mode      ua.MessageSecurityMode
	}{
		Endpoints: endpoints,
		Policy:    policy,
		Mode:      mode,
	}
	mock.lockSelectEndpoint.Lock()
	mock.calls.SelectEndpoint = append(mock.calls.SelectEndpoint, callInfo)
	mock.lockSelectEndpoint.Unlock()
	return mock.SelectEndpointFunc(endpoints, policy, mode)
}

// SelectEndpointCalls gets all the calls that were made to SelectEndpoint.
// Check the length with:
//     len(mockedClientExtDeps.SelectEndpointCalls())
func (mock *ClientExtDepsMock) SelectEndpointCalls() []struct {
	Endpoints []*ua.EndpointDescription
	Policy    string
	Mode      ua.MessageSecurityMode
} {
	var calls []struct {
		Endpoints []*ua.EndpointDescription
		Policy    string
		Mode      ua.MessageSecurityMode
	}
	mock.lockSelectEndpoint.RLock()
	calls = mock.calls.SelectEndpoint
	mock.lockSelectEndpoint.RUnlock()
	return calls
}

// Ensure, that RawClientProviderMock does implement RawClientProvider.
// If this is not the case, regenerate this file with moq.
var _ RawClientProvider = &RawClientProviderMock{}

// RawClientProviderMock is a mock implementation of RawClientProvider.
//
// 	func TestSomethingThatUsesRawClientProvider(t *testing.T) {
//
// 		// make and configure a mocked RawClientProvider
// 		mockedRawClientProvider := &RawClientProviderMock{
// 			CallWithContextFunc: func(ctx context.Context, req *ua.CallMethodRequest) (*ua.CallMethodResult, error) {
// 				panic("mock out the CallWithContext method")
// 			},
// 			ConnectFunc: func(contextMoqParam context.Context) error {
// 				panic("mock out the Connect method")
// 			},
// 			NamespaceArrayWithContextFunc: func(ctx context.Context) ([]string, error) {
// 				panic("mock out the NamespaceArrayWithContext method")
// 			},
// 		}
//
// 		// use mockedRawClientProvider in code that requires RawClientProvider
// 		// and then make assertions.
//
// 	}
type RawClientProviderMock struct {
	// CallWithContextFunc mocks the CallWithContext method.
	CallWithContextFunc func(ctx context.Context, req *ua.CallMethodRequest) (*ua.CallMethodResult, error)

	// ConnectFunc mocks the Connect method.
	ConnectFunc func(contextMoqParam context.Context) error

	// NamespaceArrayWithContextFunc mocks the NamespaceArrayWithContext method.
	NamespaceArrayWithContextFunc func(ctx context.Context) ([]string, error)

	// calls tracks calls to the methods.
	calls struct {
		// CallWithContext holds details about calls to the CallWithContext method.
		CallWithContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *ua.CallMethodRequest
		}
		// Connect holds details about calls to the Connect method.
		Connect []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// NamespaceArrayWithContext holds details about calls to the NamespaceArrayWithContext method.
		NamespaceArrayWithContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockCallWithContext           sync.RWMutex
	lockConnect                   sync.RWMutex
	lockNamespaceArrayWithContext sync.RWMutex
}

// CallWithContext calls CallWithContextFunc.
func (mock *RawClientProviderMock) CallWithContext(ctx context.Context, req *ua.CallMethodRequest) (*ua.CallMethodResult, error) {
	if mock.CallWithContextFunc == nil {
		panic("RawClientProviderMock.CallWithContextFunc: method is nil but RawClientProvider.CallWithContext was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *ua.CallMethodRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockCallWithContext.Lock()
	mock.calls.CallWithContext = append(mock.calls.CallWithContext, callInfo)
	mock.lockCallWithContext.Unlock()
	return mock.CallWithContextFunc(ctx, req)
}

// CallWithContextCalls gets all the calls that were made to CallWithContext.
// Check the length with:
//     len(mockedRawClientProvider.CallWithContextCalls())
func (mock *RawClientProviderMock) CallWithContextCalls() []struct {
	Ctx context.Context
	Req *ua.CallMethodRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *ua.CallMethodRequest
	}
	mock.lockCallWithContext.RLock()
	calls = mock.calls.CallWithContext
	mock.lockCallWithContext.RUnlock()
	return calls
}

// Connect calls ConnectFunc.
func (mock *RawClientProviderMock) Connect(contextMoqParam context.Context) error {
	if mock.ConnectFunc == nil {
		panic("RawClientProviderMock.ConnectFunc: method is nil but RawClientProvider.Connect was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockConnect.Lock()
	mock.calls.Connect = append(mock.calls.Connect, callInfo)
	mock.lockConnect.Unlock()
	return mock.ConnectFunc(contextMoqParam)
}

// ConnectCalls gets all the calls that were made to Connect.
// Check the length with:
//     len(mockedRawClientProvider.ConnectCalls())
func (mock *RawClientProviderMock) ConnectCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockConnect.RLock()
	calls = mock.calls.Connect
	mock.lockConnect.RUnlock()
	return calls
}

// NamespaceArrayWithContext calls NamespaceArrayWithContextFunc.
func (mock *RawClientProviderMock) NamespaceArrayWithContext(ctx context.Context) ([]string, error) {
	if mock.NamespaceArrayWithContextFunc == nil {
		panic("RawClientProviderMock.NamespaceArrayWithContextFunc: method is nil but RawClientProvider.NamespaceArrayWithContext was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockNamespaceArrayWithContext.Lock()
	mock.calls.NamespaceArrayWithContext = append(mock.calls.NamespaceArrayWithContext, callInfo)
	mock.lockNamespaceArrayWithContext.Unlock()
	return mock.NamespaceArrayWithContextFunc(ctx)
}

// NamespaceArrayWithContextCalls gets all the calls that were made to NamespaceArrayWithContext.
// Check the length with:
//     len(mockedRawClientProvider.NamespaceArrayWithContextCalls())
func (mock *RawClientProviderMock) NamespaceArrayWithContextCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockNamespaceArrayWithContext.RLock()
	calls = mock.calls.NamespaceArrayWithContext
	mock.lockNamespaceArrayWithContext.RUnlock()
	return calls
}

// Ensure, that SecurityProviderMock does implement SecurityProvider.
// If this is not the case, regenerate this file with moq.
var _ SecurityProvider = &SecurityProviderMock{}

// SecurityProviderMock is a mock implementation of SecurityProvider.
//
// 	func TestSomethingThatUsesSecurityProvider(t *testing.T) {
//
// 		// make and configure a mocked SecurityProvider
// 		mockedSecurityProvider := &SecurityProviderMock{
// 			MessageSecurityModeFunc: func() ua.MessageSecurityMode {
// 				panic("mock out the MessageSecurityMode method")
// 			},
// 			OptionsFunc: func(ep *ua.EndpointDescription) []opcua.Option {
// 				panic("mock out the Options method")
// 			},
// 			PolicyFunc: func() string {
// 				panic("mock out the Policy method")
// 			},
// 		}
//
// 		// use mockedSecurityProvider in code that requires SecurityProvider
// 		// and then make assertions.
//
// 	}
type SecurityProviderMock struct {
	// MessageSecurityModeFunc mocks the MessageSecurityMode method.
	MessageSecurityModeFunc func() ua.MessageSecurityMode

	// OptionsFunc mocks the Options method.
	OptionsFunc func(ep *ua.EndpointDescription) []opcua.Option

	// PolicyFunc mocks the Policy method.
	PolicyFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// MessageSecurityMode holds details about calls to the MessageSecurityMode method.
		MessageSecurityMode []struct {
		}
		// Options holds details about calls to the Options method.
		Options []struct {
			// Ep is the ep argument value.
			Ep *ua.EndpointDescription
		}
		// Policy holds details about calls to the Policy method.
		Policy []struct {
		}
	}
	lockMessageSecurityMode sync.RWMutex
	lockOptions             sync.RWMutex
	lockPolicy              sync.RWMutex
}

// MessageSecurityMode calls MessageSecurityModeFunc.
func (mock *SecurityProviderMock) MessageSecurityMode() ua.MessageSecurityMode {
	if mock.MessageSecurityModeFunc == nil {
		panic("SecurityProviderMock.MessageSecurityModeFunc: method is nil but SecurityProvider.MessageSecurityMode was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMessageSecurityMode.Lock()
	mock.calls.MessageSecurityMode = append(mock.calls.MessageSecurityMode, callInfo)
	mock.lockMessageSecurityMode.Unlock()
	return mock.MessageSecurityModeFunc()
}

// MessageSecurityModeCalls gets all the calls that were made to MessageSecurityMode.
// Check the length with:
//     len(mockedSecurityProvider.MessageSecurityModeCalls())
func (mock *SecurityProviderMock) MessageSecurityModeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMessageSecurityMode.RLock()
	calls = mock.calls.MessageSecurityMode
	mock.lockMessageSecurityMode.RUnlock()
	return calls
}

// Options calls OptionsFunc.
func (mock *SecurityProviderMock) Options(ep *ua.EndpointDescription) []opcua.Option {
	if mock.OptionsFunc == nil {
		panic("SecurityProviderMock.OptionsFunc: method is nil but SecurityProvider.Options was just called")
	}
	callInfo := struct {
		Ep *ua.EndpointDescription
	}{
		Ep: ep,
	}
	mock.lockOptions.Lock()
	mock.calls.Options = append(mock.calls.Options, callInfo)
	mock.lockOptions.Unlock()
	return mock.OptionsFunc(ep)
}

// OptionsCalls gets all the calls that were made to Options.
// Check the length with:
//     len(mockedSecurityProvider.OptionsCalls())
func (mock *SecurityProviderMock) OptionsCalls() []struct {
	Ep *ua.EndpointDescription
} {
	var calls []struct {
		Ep *ua.EndpointDescription
	}
	mock.lockOptions.RLock()
	calls = mock.calls.Options
	mock.lockOptions.RUnlock()
	return calls
}

// Policy calls PolicyFunc.
func (mock *SecurityProviderMock) Policy() string {
	if mock.PolicyFunc == nil {
		panic("SecurityProviderMock.PolicyFunc: method is nil but SecurityProvider.Policy was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPolicy.Lock()
	mock.calls.Policy = append(mock.calls.Policy, callInfo)
	mock.lockPolicy.Unlock()
	return mock.PolicyFunc()
}

// PolicyCalls gets all the calls that were made to Policy.
// Check the length with:
//     len(mockedSecurityProvider.PolicyCalls())
func (mock *SecurityProviderMock) PolicyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPolicy.RLock()
	calls = mock.calls.Policy
	mock.lockPolicy.RUnlock()
	return calls
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package opcua

import (
	"github.com/gopcua/opcua"
	"github.com/gopcua/opcua/ua"
	"sync"
)

// Ensure, that SecurityOptsProviderMock does implement SecurityOptsProvider.
// If this is not the case, regenerate this file with moq.
var _ SecurityOptsProvider = &SecurityOptsProviderMock{}

// SecurityOptsProviderMock is a mock implementation of SecurityOptsProvider.
//
// 	func TestSomethingThatUsesSecurityOptsProvider(t *testing.T) {
//
// 		// make and configure a mocked SecurityOptsProvider
// 		mockedSecurityOptsProvider := &SecurityOptsProviderMock{
// 			AuthUsernameFunc: func(user string, pass string) opcua.Option {
// 				panic("mock out the AuthUsername method")
// 			},
// 			CertificateFileFunc: func(filename string) opcua.Option {
// 				panic("mock out the CertificateFile method")
// 			},
// 			PrivateKeyFileFunc: func(filename string) opcua.Option {
// 				panic("mock out the PrivateKeyFile method")
// 			},
// 			SecurityFromEndpointFunc: func(ep *ua.EndpointDescription, authType ua.UserTokenType) opcua.Option {
// 				panic("mock out the SecurityFromEndpoint method")
// 			},
// 		}
//
// 		// use mockedSecurityOptsProvider in code that requires SecurityOptsProvider
// 		// and then make assertions.
//
// 	}
type SecurityOptsProviderMock struct {
	// AuthUsernameFunc mocks the AuthUsername method.
	AuthUsernameFunc func(user string, pass string) opcua.Option

	// CertificateFileFunc mocks the CertificateFile method.
	CertificateFileFunc func(filename string) opcua.Option

	// PrivateKeyFileFunc mocks the PrivateKeyFile method.
	PrivateKeyFileFunc func(filename string) opcua.Option

	// SecurityFromEndpointFunc mocks the SecurityFromEndpoint method.
	SecurityFromEndpointFunc func(ep *ua.EndpointDescription, authType ua.UserTokenType) opcua.Option

	// calls tracks calls to the methods.
	calls struct {
		// AuthUsername holds details about calls to the AuthUsername method.
		AuthUsername []struct {
			// User is the user argument value.
			User string
			// Pass is the pass argument value.
			Pass string
		}
		// CertificateFile holds details about calls to the CertificateFile method.
		CertificateFile []struct {
			// Filename is the filename argument value.
			Filename string
		}
		// PrivateKeyFile holds details about calls to the PrivateKeyFile method.
		PrivateKeyFile []struct {
			// Filename is the filename argument value.
			Filename string
		}
		// SecurityFromEndpoint holds details about calls to the SecurityFromEndpoint method.
		SecurityFromEndpoint []struct {
			// Ep is the ep argument value.
			Ep *ua.EndpointDescription
			// AuthType is the authType argument value.
			AuthType ua.UserTokenType
		}
	}
	lockAuthUsername         sync.RWMutex
	lockCertificateFile      sync.RWMutex
	lockPrivateKeyFile       sync.RWMutex
	lockSecurityFromEndpoint sync.RWMutex
}

// AuthUsername calls AuthUsernameFunc.
func (mock *SecurityOptsProviderMock) AuthUsername(user string, pass string) opcua.Option {
	if mock.AuthUsernameFunc == nil {
		panic("SecurityOptsProviderMock.AuthUsernameFunc: method is nil but SecurityOptsProvider.AuthUsername was just called")
	}
	callInfo := struct {
		User string
		Pass string
	}{
		User: user,
		Pass: pass,
	}
	mock.lockAuthUsername.Lock()
	mock.calls.AuthUsername = append(mock.calls.AuthUsername, callInfo)
	mock.lockAuthUsername.Unlock()
	return mock.AuthUsernameFunc(user, pass)
}

// AuthUsernameCalls gets all the calls that were made to AuthUsername.
// Check the length with:
//     len(mockedSecurityOptsProvider.AuthUsernameCalls())
func (mock *SecurityOptsProviderMock) AuthUsernameCalls() []struct {
	User string
	Pass string
} {
	var calls []struct {
		User string
		Pass string
	}
	mock.lockAuthUsername.RLock()
	calls = mock.calls.AuthUsername
	mock.lockAuthUsername.RUnlock()
	return calls
}

// CertificateFile calls CertificateFileFunc.
func (mock *SecurityOptsProviderMock) CertificateFile(filename string) opcua.Option {
	if mock.CertificateFileFunc == nil {
		panic("SecurityOptsProviderMock.CertificateFileFunc: method is nil but SecurityOptsProvider.CertificateFile was just called")
	}
	callInfo := struct {
		Filename string
	}{
		Filename: filename,
	}
	mock.lockCertificateFile.Lock()
	mock.calls.CertificateFile = append(mock.calls.CertificateFile, callInfo)
	mock.lockCertificateFile.Unlock()
	return mock.CertificateFileFunc(filename)
}

// CertificateFileCalls gets all the calls that were made to CertificateFile.
// Check the length with:
//     len(mockedSecurityOptsProvider.CertificateFileCalls())
func (mock *SecurityOptsProviderMock) CertificateFileCalls() []struct {
	Filename string
} {
	var calls []struct {
		Filename string
	}
	mock.lockCertificateFile.RLock()
	calls = mock.calls.CertificateFile
	mock.lockCertificateFile.RUnlock()
	return calls
}

// PrivateKeyFile calls PrivateKeyFileFunc.
func (mock *SecurityOptsProviderMock) PrivateKeyFile(filename string) opcua.Option {
	if mock.PrivateKeyFileFunc == nil {
		panic("SecurityOptsProviderMock.PrivateKeyFileFunc: method is nil but SecurityOptsProvider.PrivateKeyFile was just called")
	}
	callInfo := struct {
		Filename string
	}{
		Filename: filename,
	}
	mock.lockPrivateKeyFile.Lock()
	mock.calls.PrivateKeyFile = append(mock.calls.PrivateKeyFile, callInfo)
	mock.lockPrivateKeyFile.Unlock()
	return mock.PrivateKeyFileFunc(filename)
}

// PrivateKeyFileCalls gets all the calls that were made to PrivateKeyFile.
// Check the length with:
//     len(mockedSecurityOptsProvider.PrivateKeyFileCalls())
func (mock *SecurityOptsProviderMock) PrivateKeyFileCalls() []struct {
	Filename string
} {
	var calls []struct {
		Filename string
	}
	mock.lockPrivateKeyFile.RLock()
	calls = mock.calls.PrivateKeyFile
	mock.lockPrivateKeyFile.RUnlock()
	return calls
}

// SecurityFromEndpoint calls SecurityFromEndpointFunc.
func (mock *SecurityOptsProviderMock) SecurityFromEndpoint(ep *ua.EndpointDescription, authType ua.UserTokenType) opcua.Option {
	if mock.SecurityFromEndpointFunc == nil {
		panic("SecurityOptsProviderMock.SecurityFromEndpointFunc: method is nil but SecurityOptsProvider.SecurityFromEndpoint was just called")
	}
	callInfo := struct {
		Ep       *ua.EndpointDescription
		AuthType ua.UserTokenType
	}{
		Ep:       ep,
		AuthType: authType,
	}
	mock.lockSecurityFromEndpoint.Lock()
	mock.calls.SecurityFromEndpoint = append(mock.calls.SecurityFromEndpoint, callInfo)
	mock.lockSecurityFromEndpoint.Unlock()
	return mock.SecurityFromEndpointFunc(ep, authType)
}

// SecurityFromEndpointCalls gets all the calls that were made to SecurityFromEndpoint.
// Check the length with:
//     len(mockedSecurityOptsProvider.SecurityFromEndpointCalls())
func (mock *SecurityOptsProviderMock) SecurityFromEndpointCalls() []struct {
	Ep       *ua.EndpointDescription
	AuthType ua.UserTokenType
} {
	var calls []struct {
		Ep       *ua.EndpointDescription
		AuthType ua.UserTokenType
	}
	mock.lockSecurityFromEndpoint.RLock()
	calls = mock.calls.SecurityFromEndpoint
	mock.lockSecurityFromEndpoint.RUnlock()
	return calls
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package opcua

import (
	"context"
	"github.com/gopcua/opcua"
	"github.com/gopcua/opcua/ua"
	"sync"
	"time"
)

// Ensure, that ClientProviderMock does implement ClientProvider.
// If this is not the case, regenerate this file with moq.
var _ ClientProvider = &ClientProviderMock{}

// ClientProviderMock is a mock implementation of ClientProvider.
//
//	func TestSomethingThatUsesClientProvider(t *testing.T) {
//
//		// make and configure a mocked ClientProvider
//		mockedClientProvider := &ClientProviderMock{
//			CloseWithContextFunc: func(ctx context.Context) error {
//				panic("mock out the CloseWithContext method")
//			},
//			ConnectFunc: func(ctx context.Context) error {
//				panic("mock out the Connect method")
//			},
//			FindNamespaceWithContextFunc: func(ctx context.Context, name string) (uint16, error) {
//				panic("mock out the FindNamespaceWithContext method")
//			},
//			ReadWithContextFunc: func(ctx context.Context, req *ua.ReadRequest) (*ua.ReadResponse, error) {
//				panic("mock out the ReadWithContext method")
//			},
//			StateFunc: func() opcua.ConnState {
//				panic("mock out the State method")
//			},
//			SubscribeWithContextFunc: func(ctx context.Context, params *opcua.SubscriptionParameters, notifyCh chan<- *opcua.PublishNotificationData) (*opcua.Subscription, error) {
//				panic("mock out the SubscribeWithContext method")
//			},
//		}
//
//		// use mockedClientProvider in code that requires ClientProvider
//		// and then make assertions.
//
//	}
type ClientProviderMock struct {
	// CloseWithContextFunc mocks the CloseWithContext method.
	CloseWithContextFunc func(ctx context.Context) error

	// ConnectFunc mocks the Connect method.
	ConnectFunc func(ctx context.Context) error

	// FindNamespaceWithContextFunc mocks the FindNamespaceWithContext method.
	FindNamespaceWithContextFunc func(ctx context.Context, name string) (uint16, error)

	// ReadWithContextFunc mocks the ReadWithContext method.
	ReadWithContextFunc func(ctx context.Context, req *ua.ReadRequest) (*ua.ReadResponse, error)

	// StateFunc mocks the State method.
	StateFunc func() opcua.ConnState

	// SubscribeWithContextFunc mocks the SubscribeWithContext method.
	SubscribeWithContextFunc func(ctx context.Context, params *opcua.SubscriptionParameters, notifyCh chan<- *opcua.PublishNotificationData) (*opcua.Subscription, error)

	// calls tracks calls to the methods.
	calls struct {
		// CloseWithContext holds details about calls to the CloseWithContext method.
		CloseWithContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Connect holds details about calls to the Connect method.
		Connect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FindNamespaceWithContext holds details about calls to the FindNamespaceWithContext method.
		FindNamespaceWithContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// ReadWithContext holds details about calls to the ReadWithContext method.
		ReadWithContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *ua.ReadRequest
		}
		// State holds details about calls to the State method.
		State []struct {
		}
		// SubscribeWithContext holds details about calls to the SubscribeWithContext method.
		SubscribeWithContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params *opcua.SubscriptionParameters
			// NotifyCh is the notifyCh argument value.
			NotifyCh chan<- *opcua.PublishNotificationData
		}
	}
	lockCloseWithContext         sync.RWMutex
	lockConnect                  sync.RWMutex
	lockFindNamespaceWithContext sync.RWMutex
	lockReadWithContext          sync.RWMutex
	lockState                    sync.RWMutex
	lockSubscribeWithContext     sync.RWMutex
}

// CloseWithContext calls CloseWithContextFunc.
func (mock *ClientProviderMock) CloseWithContext(ctx context.Context) error {
	if mock.CloseWithContextFunc == nil {
		panic("ClientProviderMock.CloseWithContextFunc: method is nil but ClientProvider.CloseWithContext was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCloseWithContext.Lock()
	mock.calls.CloseWithContext = append(mock.calls.CloseWithContext, callInfo)
	mock.lockCloseWithContext.Unlock()
	return mock.CloseWithContextFunc(ctx)
}

// CloseWithContextCalls gets all the calls that were made to CloseWithContext.
// Check the length with:
//
//	len(mockedClientProvider.CloseWithContextCalls())
func (mock *ClientProviderMock) CloseWithContextCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCloseWithContext.RLock()
	calls = mock.calls.CloseWithContext
	mock.lockCloseWithContext.RUnlock()
	return calls
}

// Connect calls ConnectFunc.
func (mock *ClientProviderMock) Connect(ctx context.Context) error {
	if mock.ConnectFunc == nil {
		panic("ClientProviderMock.ConnectFunc: method is nil but ClientProvider.Connect was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockConnect.Lock()
	mock.calls.Connect = append(mock.calls.Connect, callInfo)
	mock.lockConnect.Unlock()
	return mock.ConnectFunc(ctx)
}

// ConnectCalls gets all the calls that were made to Connect.
// Check the length with:
//
//	len(mockedClientProvider.ConnectCalls())
func (mock *ClientProviderMock) ConnectCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockConnect.RLock()
	calls = mock.calls.Connect
	mock.lockConnect.RUnlock()
	return calls
}

// FindNamespaceWithContext calls FindNamespaceWithContextFunc.
func (mock *ClientProviderMock) FindNamespaceWithContext(ctx context.Context, name string) (uint16, error) {
	if mock.FindNamespaceWithContextFunc == nil {
		panic("ClientProviderMock.FindNamespaceWithContextFunc: method is nil but ClientProvider.FindNamespaceWithContext was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockFindNamespaceWithContext.Lock()
	mock.calls.FindNamespaceWithContext = append(mock.calls.FindNamespaceWithContext, callInfo)
	mock.lockFindNamespaceWithContext.Unlock()
	return mock.FindNamespaceWithContextFunc(ctx, name)
}

// FindNamespaceWithContextCalls gets all the calls that were made to FindNamespaceWithContext.
// Check the length with:
//
//	len(mockedClientProvider.FindNamespaceWithContextCalls())
func (mock *ClientProviderMock) FindNamespaceWithContextCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockFindNamespaceWithContext.RLock()
	calls = mock.calls.FindNamespaceWithContext
	mock.lockFindNamespaceWithContext.RUnlock()
	return calls
}

// ReadWithContext calls ReadWithContextFunc.
func (mock *ClientProviderMock) ReadWithContext(ctx context.Context, req *ua.ReadRequest) (*ua.ReadResponse, error) {
	if mock.ReadWithContextFunc == nil {
		panic("ClientProviderMock.ReadWithContextFunc: method is nil but ClientProvider.ReadWithContext was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *ua.ReadRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockReadWithContext.Lock()
	mock.calls.ReadWithContext = append(mock.calls.ReadWithContext, callInfo)
	mock.lockReadWithContext.Unlock()
	return mock.ReadWithContextFunc(ctx, req)
}

// ReadWithContextCalls gets all the calls that were made to ReadWithContext.
// Check the length with:
//
//	len(mockedClientProvider.ReadWithContextCalls())
func (mock *ClientProviderMock) ReadWithContextCalls() []struct {
	Ctx context.Context
	Req *ua.ReadRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *ua.ReadRequest
	}
	mock.lockReadWithContext.RLock()
	calls = mock.calls.ReadWithContext
	mock.lockReadWithContext.RUnlock()
	return calls
}

// State calls StateFunc.
func (mock *ClientProviderMock) State() opcua.ConnState {
	if mock.StateFunc == nil {
		panic("ClientProviderMock.StateFunc: method is nil but ClientProvider.State was just called")
	}
	callInfo := struct {
	}{}
	mock.lockState.Lock()
	mock.calls.State = append(mock.calls.State, callInfo)
	mock.lockState.Unlock()
	return mock.StateFunc()
}

// StateCalls gets all the calls that were made to State.
// Check the length with:
//
//	len(mockedClientProvider.StateCalls())
func (mock *ClientProviderMock) StateCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockState.RLock()
	calls = mock.calls.State
	mock.lockState.RUnlock()
	return calls
}

// SubscribeWithContext calls SubscribeWithContextFunc.
func (mock *ClientProviderMock) SubscribeWithContext(ctx context.Context, params *opcua.SubscriptionParameters, notifyCh chan<- *opcua.PublishNotificationData) (*opcua.Subscription, error) {
	if mock.SubscribeWithContextFunc == nil {
		panic("ClientProviderMock.SubscribeWithContextFunc: method is nil but ClientProvider.SubscribeWithContext was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Params   *opcua.SubscriptionParameters
		NotifyCh chan<- *opcua.PublishNotificationData
	}{
		Ctx:      ctx,
		Params:   params,
		NotifyCh: notifyCh,
	}
	mock.lockSubscribeWithContext.Lock()
	mock.calls.SubscribeWithContext = append(mock.calls.SubscribeWithContext, callInfo)
	mock.lockSubscribeWithContext.Unlock()
	return mock.SubscribeWithContextFunc(ctx, params, notifyCh)
}

// SubscribeWithContextCalls gets all the calls that were made to SubscribeWithContext.
// Check the length with:
//
//	len(mockedClientProvider.SubscribeWithContextCalls())
func (mock *ClientProviderMock) SubscribeWithContextCalls() []struct {
	Ctx      context.Context
	Params   *opcua.SubscriptionParameters
	NotifyCh chan<- *opcua.PublishNotificationData
} {
	var calls []struct {
		Ctx      context.Context
		Params   *opcua.SubscriptionParameters
		NotifyCh chan<- *opcua.PublishNotificationData
	}
	mock.lockSubscribeWithContext.RLock()
	calls = mock.calls.SubscribeWithContext
	mock.lockSubscribeWithContext.RUnlock()
	return calls
}

// Ensure, that SubscriptionManagerProviderMock does implement SubscriptionManagerProvider.
// If this is not the case, regenerate this file with moq.
var _ SubscriptionManagerProvider = &SubscriptionManagerProviderMock{}

// SubscriptionManagerProviderMock is a mock implementation of SubscriptionManagerProvider.
//
//	func TestSomethingThatUsesSubscriptionManagerProvider(t *testing.T) {
//
//		// make and configure a mocked SubscriptionManagerProvider
//		mockedSubscriptionManagerProvider := &SubscriptionManagerProviderMock{
//			CreateFunc: func(ctx context.Context, i time.Duration, nc chan<- *opcua.PublishNotificationData) (*Subscription, error) {
//				panic("mock out the Create method")
//			},
//		}
//
//		// use mockedSubscriptionManagerProvider in code that requires SubscriptionManagerProvider
//		// and then make assertions.
//
//	}
type SubscriptionManagerProviderMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, i time.Duration, nc chan<- *opcua.PublishNotificationData) (*Subscription, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// I is the i argument value.
			I time.Duration
			// Nc is the nc argument value.
			Nc chan<- *opcua.PublishNotificationData
		}
	}
	lockCreate sync.RWMutex
}

// Create calls CreateFunc.
func (mock *SubscriptionManagerProviderMock) Create(ctx context.Context, i time.Duration, nc chan<- *opcua.PublishNotificationData) (*Subscription, error) {
	if mock.CreateFunc == nil {
		panic("SubscriptionManagerProviderMock.CreateFunc: method is nil but SubscriptionManagerProvider.Create was just called")
	}
	callInfo := struct {
		Ctx context.Context
		I   time.Duration
		Nc  chan<- *opcua.PublishNotificationData
	}{
		Ctx: ctx,
		I:   i,
		Nc:  nc,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, i, nc)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedSubscriptionManagerProvider.CreateCalls())
func (mock *SubscriptionManagerProviderMock) CreateCalls() []struct {
	Ctx context.Context
	I   time.Duration
	Nc  chan<- *opcua.PublishNotificationData
} {
	var calls []struct {
		Ctx context.Context
		I   time.Duration
		Nc  chan<- *opcua.PublishNotificationData
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Ensure, that ChannelProviderMock does implement ChannelProvider.
// If this is not the case, regenerate this file with moq.
var _ ChannelProvider = &ChannelProviderMock{}

// ChannelProviderMock is a mock implementation of ChannelProvider.
//
//	func TestSomethingThatUsesChannelProvider(t *testing.T) {
//
//		// make and configure a mocked ChannelProvider
//		mockedChannelProvider := &ChannelProviderMock{
//			IntervalFunc: func() time.Duration {
//				panic("mock out the Interval method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//		}
//
//		// use mockedChannelProvider in code that requires ChannelProvider
//		// and then make assertions.
//
//	}
type ChannelProviderMock struct {
	// IntervalFunc mocks the Interval method.
	IntervalFunc func() time.Duration

	// StringFunc mocks the String method.
	StringFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Interval holds details about calls to the Interval method.
		Interval []struct {
		}
		// String holds details about calls to the String method.
		String []struct {
		}
	}
	lockInterval sync.RWMutex
	lockString   sync.RWMutex
}

// Interval calls IntervalFunc.
func (mock *ChannelProviderMock) Interval() time.Duration {
	if mock.IntervalFunc == nil {
		panic("ChannelProviderMock.IntervalFunc: method is nil but ChannelProvider.Interval was just called")
	}
	callInfo := struct {
	}{}
	mock.lockInterval.Lock()
	mock.calls.Interval = append(mock.calls.Interval, callInfo)
	mock.lockInterval.Unlock()
	return mock.IntervalFunc()
}

// IntervalCalls gets all the calls that were made to Interval.
// Check the length with:
//
//	len(mockedChannelProvider.IntervalCalls())
func (mock *ChannelProviderMock) IntervalCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockInterval.RLock()
	calls = mock.calls.Interval
	mock.lockInterval.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *ChannelProviderMock) String() string {
	if mock.StringFunc == nil {
		panic("ChannelProviderMock.StringFunc: method is nil but ChannelProvider.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedChannelProvider.StringCalls())
func (mock *ChannelProviderMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// Ensure, that NodeIDProviderMock does implement NodeIDProvider.
// If this is not the case, regenerate this file with moq.
var _ NodeIDProvider = &NodeIDProviderMock{}

// NodeIDProviderMock is a mock implementation of NodeIDProvider.
//
//	func TestSomethingThatUsesNodeIDProvider(t *testing.T) {
//
//		// make and configure a mocked NodeIDProvider
//		mockedNodeIDProvider := &NodeIDProviderMock{
//			NodeIDFunc: func(ns uint16) *ua.NodeID {
//				panic("mock out the NodeID method")
//			},
//		}
//
//		// use mockedNodeIDProvider in code that requires NodeIDProvider
//		// and then make assertions.
//
//	}
type NodeIDProviderMock struct {
	// NodeIDFunc mocks the NodeID method.
	NodeIDFunc func(ns uint16) *ua.NodeID

	// calls tracks calls to the methods.
	calls struct {
		// NodeID holds details about calls to the NodeID method.
		NodeID []struct {
			// Ns is the ns argument value.
			Ns uint16
		}
	}
	lockNodeID sync.RWMutex
}

// NodeID calls NodeIDFunc.
func (mock *NodeIDProviderMock) NodeID(ns uint16) *ua.NodeID {
	if mock.NodeIDFunc == nil {
		panic("NodeIDProviderMock.NodeIDFunc: method is nil but NodeIDProvider.NodeID was just called")
	}
	callInfo := struct {
		Ns uint16
	}{
		Ns: ns,
	}
	mock.lockNodeID.Lock()
	mock.calls.NodeID = append(mock.calls.NodeID, callInfo)
	mock.lockNodeID.Unlock()
	return mock.NodeIDFunc(ns)
}

// NodeIDCalls gets all the calls that were made to NodeID.
// Check the length with:
//
//	len(mockedNodeIDProvider.NodeIDCalls())
func (mock *NodeIDProviderMock) NodeIDCalls() []struct {
	Ns uint16
} {
	var calls []struct {
		Ns uint16
	}
	mock.lockNodeID.RLock()
	calls = mock.calls.NodeID
	mock.lockNodeID.RUnlock()
	return calls
}

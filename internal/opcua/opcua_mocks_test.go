// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package opcua

import (
	"context"
	"github.com/gopcua/opcua"
	"github.com/gopcua/opcua/monitor"
	"github.com/gopcua/opcua/ua"
	"sync"
)

// Ensure, that ClientMock does implement Client.
// If this is not the case, regenerate this file with moq.
var _ Client = &ClientMock{}

// ClientMock is a mock implementation of Client.
//
// 	func TestSomethingThatUsesClient(t *testing.T) {
//
// 		// make and configure a mocked Client
// 		mockedClient := &ClientMock{
// 			CloseFunc: func() error {
// 				panic("mock out the Close method")
// 			},
// 			ConnectFunc: func(contextMoqParam context.Context) error {
// 				panic("mock out the Connect method")
// 			},
// 		}
//
// 		// use mockedClient in code that requires Client
// 		// and then make assertions.
//
// 	}
type ClientMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ConnectFunc mocks the Connect method.
	ConnectFunc func(contextMoqParam context.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Connect holds details about calls to the Connect method.
		Connect []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
	}
	lockClose   sync.RWMutex
	lockConnect sync.RWMutex
}

// Close calls CloseFunc.
func (mock *ClientMock) Close() error {
	if mock.CloseFunc == nil {
		panic("ClientMock.CloseFunc: method is nil but Client.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedClient.CloseCalls())
func (mock *ClientMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Connect calls ConnectFunc.
func (mock *ClientMock) Connect(contextMoqParam context.Context) error {
	if mock.ConnectFunc == nil {
		panic("ClientMock.ConnectFunc: method is nil but Client.Connect was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockConnect.Lock()
	mock.calls.Connect = append(mock.calls.Connect, callInfo)
	mock.lockConnect.Unlock()
	return mock.ConnectFunc(contextMoqParam)
}

// ConnectCalls gets all the calls that were made to Connect.
// Check the length with:
//     len(mockedClient.ConnectCalls())
func (mock *ClientMock) ConnectCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockConnect.RLock()
	calls = mock.calls.Connect
	mock.lockConnect.RUnlock()
	return calls
}

// Ensure, that NodeMonitorMock does implement NodeMonitor.
// If this is not the case, regenerate this file with moq.
var _ NodeMonitor = &NodeMonitorMock{}

// NodeMonitorMock is a mock implementation of NodeMonitor.
//
// 	func TestSomethingThatUsesNodeMonitor(t *testing.T) {
//
// 		// make and configure a mocked NodeMonitor
// 		mockedNodeMonitor := &NodeMonitorMock{
// 			ChanSubscribeFunc: func(contextMoqParam context.Context, subscriptionParameters *opcua.SubscriptionParameters, dataChangeMessageCh chan<- *monitor.DataChangeMessage, strings ...string) (*monitor.Subscription, error) {
// 				panic("mock out the ChanSubscribe method")
// 			},
// 			SetErrorHandlerFunc: func(cb monitor.ErrHandler)  {
// 				panic("mock out the SetErrorHandler method")
// 			},
// 		}
//
// 		// use mockedNodeMonitor in code that requires NodeMonitor
// 		// and then make assertions.
//
// 	}
type NodeMonitorMock struct {
	// ChanSubscribeFunc mocks the ChanSubscribe method.
	ChanSubscribeFunc func(contextMoqParam context.Context, subscriptionParameters *opcua.SubscriptionParameters, dataChangeMessageCh chan<- *monitor.DataChangeMessage, strings ...string) (*monitor.Subscription, error)

	// SetErrorHandlerFunc mocks the SetErrorHandler method.
	SetErrorHandlerFunc func(cb monitor.ErrHandler)

	// calls tracks calls to the methods.
	calls struct {
		// ChanSubscribe holds details about calls to the ChanSubscribe method.
		ChanSubscribe []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// SubscriptionParameters is the subscriptionParameters argument value.
			SubscriptionParameters *opcua.SubscriptionParameters
			// DataChangeMessageCh is the dataChangeMessageCh argument value.
			DataChangeMessageCh chan<- *monitor.DataChangeMessage
			// Strings is the strings argument value.
			Strings []string
		}
		// SetErrorHandler holds details about calls to the SetErrorHandler method.
		SetErrorHandler []struct {
			// Cb is the cb argument value.
			Cb monitor.ErrHandler
		}
	}
	lockChanSubscribe   sync.RWMutex
	lockSetErrorHandler sync.RWMutex
}

// ChanSubscribe calls ChanSubscribeFunc.
func (mock *NodeMonitorMock) ChanSubscribe(contextMoqParam context.Context, subscriptionParameters *opcua.SubscriptionParameters, dataChangeMessageCh chan<- *monitor.DataChangeMessage, strings ...string) (*monitor.Subscription, error) {
	if mock.ChanSubscribeFunc == nil {
		panic("NodeMonitorMock.ChanSubscribeFunc: method is nil but NodeMonitor.ChanSubscribe was just called")
	}
	callInfo := struct {
		ContextMoqParam        context.Context
		SubscriptionParameters *opcua.SubscriptionParameters
		DataChangeMessageCh    chan<- *monitor.DataChangeMessage
		Strings                []string
	}{
		ContextMoqParam:        contextMoqParam,
		SubscriptionParameters: subscriptionParameters,
		DataChangeMessageCh:    dataChangeMessageCh,
		Strings:                strings,
	}
	mock.lockChanSubscribe.Lock()
	mock.calls.ChanSubscribe = append(mock.calls.ChanSubscribe, callInfo)
	mock.lockChanSubscribe.Unlock()
	return mock.ChanSubscribeFunc(contextMoqParam, subscriptionParameters, dataChangeMessageCh, strings...)
}

// ChanSubscribeCalls gets all the calls that were made to ChanSubscribe.
// Check the length with:
//     len(mockedNodeMonitor.ChanSubscribeCalls())
func (mock *NodeMonitorMock) ChanSubscribeCalls() []struct {
	ContextMoqParam        context.Context
	SubscriptionParameters *opcua.SubscriptionParameters
	DataChangeMessageCh    chan<- *monitor.DataChangeMessage
	Strings                []string
} {
	var calls []struct {
		ContextMoqParam        context.Context
		SubscriptionParameters *opcua.SubscriptionParameters
		DataChangeMessageCh    chan<- *monitor.DataChangeMessage
		Strings                []string
	}
	mock.lockChanSubscribe.RLock()
	calls = mock.calls.ChanSubscribe
	mock.lockChanSubscribe.RUnlock()
	return calls
}

// SetErrorHandler calls SetErrorHandlerFunc.
func (mock *NodeMonitorMock) SetErrorHandler(cb monitor.ErrHandler) {
	if mock.SetErrorHandlerFunc == nil {
		panic("NodeMonitorMock.SetErrorHandlerFunc: method is nil but NodeMonitor.SetErrorHandler was just called")
	}
	callInfo := struct {
		Cb monitor.ErrHandler
	}{
		Cb: cb,
	}
	mock.lockSetErrorHandler.Lock()
	mock.calls.SetErrorHandler = append(mock.calls.SetErrorHandler, callInfo)
	mock.lockSetErrorHandler.Unlock()
	mock.SetErrorHandlerFunc(cb)
}

// SetErrorHandlerCalls gets all the calls that were made to SetErrorHandler.
// Check the length with:
//     len(mockedNodeMonitor.SetErrorHandlerCalls())
func (mock *NodeMonitorMock) SetErrorHandlerCalls() []struct {
	Cb monitor.ErrHandler
} {
	var calls []struct {
		Cb monitor.ErrHandler
	}
	mock.lockSetErrorHandler.RLock()
	calls = mock.calls.SetErrorHandler
	mock.lockSetErrorHandler.RUnlock()
	return calls
}

// Ensure, that NewMonitorDepsMock does implement NewMonitorDeps.
// If this is not the case, regenerate this file with moq.
var _ NewMonitorDeps = &NewMonitorDepsMock{}

// NewMonitorDepsMock is a mock implementation of NewMonitorDeps.
//
// 	func TestSomethingThatUsesNewMonitorDeps(t *testing.T) {
//
// 		// make and configure a mocked NewMonitorDeps
// 		mockedNewMonitorDeps := &NewMonitorDepsMock{
// 			AuthUsernameFunc: func(user string, pass string) opcua.Option {
// 				panic("mock out the AuthUsername method")
// 			},
// 			CertificateFileFunc: func(filename string) opcua.Option {
// 				panic("mock out the CertificateFile method")
// 			},
// 			GetEndpointsFunc: func(ctx context.Context, endpoint string, opts ...opcua.Option) ([]*ua.EndpointDescription, error) {
// 				panic("mock out the GetEndpoints method")
// 			},
// 			NewClientFunc: func(endpoint string, opts ...opcua.Option) Client {
// 				panic("mock out the NewClient method")
// 			},
// 			NewNodeMonitorFunc: func(client Client) (NodeMonitor, error) {
// 				panic("mock out the NewNodeMonitor method")
// 			},
// 			PrivateKeyFileFunc: func(filename string) opcua.Option {
// 				panic("mock out the PrivateKeyFile method")
// 			},
// 			SecurityFromEndpointFunc: func(ep *ua.EndpointDescription, authType ua.UserTokenType) opcua.Option {
// 				panic("mock out the SecurityFromEndpoint method")
// 			},
// 			SelectEndpointFunc: func(endpoints []*ua.EndpointDescription, policy string, mode ua.MessageSecurityMode) *ua.EndpointDescription {
// 				panic("mock out the SelectEndpoint method")
// 			},
// 		}
//
// 		// use mockedNewMonitorDeps in code that requires NewMonitorDeps
// 		// and then make assertions.
//
// 	}
type NewMonitorDepsMock struct {
	// AuthUsernameFunc mocks the AuthUsername method.
	AuthUsernameFunc func(user string, pass string) opcua.Option

	// CertificateFileFunc mocks the CertificateFile method.
	CertificateFileFunc func(filename string) opcua.Option

	// GetEndpointsFunc mocks the GetEndpoints method.
	GetEndpointsFunc func(ctx context.Context, endpoint string, opts ...opcua.Option) ([]*ua.EndpointDescription, error)

	// NewClientFunc mocks the NewClient method.
	NewClientFunc func(endpoint string, opts ...opcua.Option) Client

	// NewNodeMonitorFunc mocks the NewNodeMonitor method.
	NewNodeMonitorFunc func(client Client) (NodeMonitor, error)

	// PrivateKeyFileFunc mocks the PrivateKeyFile method.
	PrivateKeyFileFunc func(filename string) opcua.Option

	// SecurityFromEndpointFunc mocks the SecurityFromEndpoint method.
	SecurityFromEndpointFunc func(ep *ua.EndpointDescription, authType ua.UserTokenType) opcua.Option

	// SelectEndpointFunc mocks the SelectEndpoint method.
	SelectEndpointFunc func(endpoints []*ua.EndpointDescription, policy string, mode ua.MessageSecurityMode) *ua.EndpointDescription

	// calls tracks calls to the methods.
	calls struct {
		// AuthUsername holds details about calls to the AuthUsername method.
		AuthUsername []struct {
			// User is the user argument value.
			User string
			// Pass is the pass argument value.
			Pass string
		}
		// CertificateFile holds details about calls to the CertificateFile method.
		CertificateFile []struct {
			// Filename is the filename argument value.
			Filename string
		}
		// GetEndpoints holds details about calls to the GetEndpoints method.
		GetEndpoints []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Endpoint is the endpoint argument value.
			Endpoint string
			// Opts is the opts argument value.
			Opts []opcua.Option
		}
		// NewClient holds details about calls to the NewClient method.
		NewClient []struct {
			// Endpoint is the endpoint argument value.
			Endpoint string
			// Opts is the opts argument value.
			Opts []opcua.Option
		}
		// NewNodeMonitor holds details about calls to the NewNodeMonitor method.
		NewNodeMonitor []struct {
			// Client is the client argument value.
			Client Client
		}
		// PrivateKeyFile holds details about calls to the PrivateKeyFile method.
		PrivateKeyFile []struct {
			// Filename is the filename argument value.
			Filename string
		}
		// SecurityFromEndpoint holds details about calls to the SecurityFromEndpoint method.
		SecurityFromEndpoint []struct {
			// Ep is the ep argument value.
			Ep *ua.EndpointDescription
			// AuthType is the authType argument value.
			AuthType ua.UserTokenType
		}
		// SelectEndpoint holds details about calls to the SelectEndpoint method.
		SelectEndpoint []struct {
			// Endpoints is the endpoints argument value.
			Endpoints []*ua.EndpointDescription
			// Policy is the policy argument value.
			Policy string
			// Mode is the mode argument value.
			Mode ua.MessageSecurityMode
		}
	}
	lockAuthUsername         sync.RWMutex
	lockCertificateFile      sync.RWMutex
	lockGetEndpoints         sync.RWMutex
	lockNewClient            sync.RWMutex
	lockNewNodeMonitor       sync.RWMutex
	lockPrivateKeyFile       sync.RWMutex
	lockSecurityFromEndpoint sync.RWMutex
	lockSelectEndpoint       sync.RWMutex
}

// AuthUsername calls AuthUsernameFunc.
func (mock *NewMonitorDepsMock) AuthUsername(user string, pass string) opcua.Option {
	if mock.AuthUsernameFunc == nil {
		panic("NewMonitorDepsMock.AuthUsernameFunc: method is nil but NewMonitorDeps.AuthUsername was just called")
	}
	callInfo := struct {
		User string
		Pass string
	}{
		User: user,
		Pass: pass,
	}
	mock.lockAuthUsername.Lock()
	mock.calls.AuthUsername = append(mock.calls.AuthUsername, callInfo)
	mock.lockAuthUsername.Unlock()
	return mock.AuthUsernameFunc(user, pass)
}

// AuthUsernameCalls gets all the calls that were made to AuthUsername.
// Check the length with:
//     len(mockedNewMonitorDeps.AuthUsernameCalls())
func (mock *NewMonitorDepsMock) AuthUsernameCalls() []struct {
	User string
	Pass string
} {
	var calls []struct {
		User string
		Pass string
	}
	mock.lockAuthUsername.RLock()
	calls = mock.calls.AuthUsername
	mock.lockAuthUsername.RUnlock()
	return calls
}

// CertificateFile calls CertificateFileFunc.
func (mock *NewMonitorDepsMock) CertificateFile(filename string) opcua.Option {
	if mock.CertificateFileFunc == nil {
		panic("NewMonitorDepsMock.CertificateFileFunc: method is nil but NewMonitorDeps.CertificateFile was just called")
	}
	callInfo := struct {
		Filename string
	}{
		Filename: filename,
	}
	mock.lockCertificateFile.Lock()
	mock.calls.CertificateFile = append(mock.calls.CertificateFile, callInfo)
	mock.lockCertificateFile.Unlock()
	return mock.CertificateFileFunc(filename)
}

// CertificateFileCalls gets all the calls that were made to CertificateFile.
// Check the length with:
//     len(mockedNewMonitorDeps.CertificateFileCalls())
func (mock *NewMonitorDepsMock) CertificateFileCalls() []struct {
	Filename string
} {
	var calls []struct {
		Filename string
	}
	mock.lockCertificateFile.RLock()
	calls = mock.calls.CertificateFile
	mock.lockCertificateFile.RUnlock()
	return calls
}

// GetEndpoints calls GetEndpointsFunc.
func (mock *NewMonitorDepsMock) GetEndpoints(ctx context.Context, endpoint string, opts ...opcua.Option) ([]*ua.EndpointDescription, error) {
	if mock.GetEndpointsFunc == nil {
		panic("NewMonitorDepsMock.GetEndpointsFunc: method is nil but NewMonitorDeps.GetEndpoints was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Endpoint string
		Opts     []opcua.Option
	}{
		Ctx:      ctx,
		Endpoint: endpoint,
		Opts:     opts,
	}
	mock.lockGetEndpoints.Lock()
	mock.calls.GetEndpoints = append(mock.calls.GetEndpoints, callInfo)
	mock.lockGetEndpoints.Unlock()
	return mock.GetEndpointsFunc(ctx, endpoint, opts...)
}

// GetEndpointsCalls gets all the calls that were made to GetEndpoints.
// Check the length with:
//     len(mockedNewMonitorDeps.GetEndpointsCalls())
func (mock *NewMonitorDepsMock) GetEndpointsCalls() []struct {
	Ctx      context.Context
	Endpoint string
	Opts     []opcua.Option
} {
	var calls []struct {
		Ctx      context.Context
		Endpoint string
		Opts     []opcua.Option
	}
	mock.lockGetEndpoints.RLock()
	calls = mock.calls.GetEndpoints
	mock.lockGetEndpoints.RUnlock()
	return calls
}

// NewClient calls NewClientFunc.
func (mock *NewMonitorDepsMock) NewClient(endpoint string, opts ...opcua.Option) Client {
	if mock.NewClientFunc == nil {
		panic("NewMonitorDepsMock.NewClientFunc: method is nil but NewMonitorDeps.NewClient was just called")
	}
	callInfo := struct {
		Endpoint string
		Opts     []opcua.Option
	}{
		Endpoint: endpoint,
		Opts:     opts,
	}
	mock.lockNewClient.Lock()
	mock.calls.NewClient = append(mock.calls.NewClient, callInfo)
	mock.lockNewClient.Unlock()
	return mock.NewClientFunc(endpoint, opts...)
}

// NewClientCalls gets all the calls that were made to NewClient.
// Check the length with:
//     len(mockedNewMonitorDeps.NewClientCalls())
func (mock *NewMonitorDepsMock) NewClientCalls() []struct {
	Endpoint string
	Opts     []opcua.Option
} {
	var calls []struct {
		Endpoint string
		Opts     []opcua.Option
	}
	mock.lockNewClient.RLock()
	calls = mock.calls.NewClient
	mock.lockNewClient.RUnlock()
	return calls
}

// NewNodeMonitor calls NewNodeMonitorFunc.
func (mock *NewMonitorDepsMock) NewNodeMonitor(client Client) (NodeMonitor, error) {
	if mock.NewNodeMonitorFunc == nil {
		panic("NewMonitorDepsMock.NewNodeMonitorFunc: method is nil but NewMonitorDeps.NewNodeMonitor was just called")
	}
	callInfo := struct {
		Client Client
	}{
		Client: client,
	}
	mock.lockNewNodeMonitor.Lock()
	mock.calls.NewNodeMonitor = append(mock.calls.NewNodeMonitor, callInfo)
	mock.lockNewNodeMonitor.Unlock()
	return mock.NewNodeMonitorFunc(client)
}

// NewNodeMonitorCalls gets all the calls that were made to NewNodeMonitor.
// Check the length with:
//     len(mockedNewMonitorDeps.NewNodeMonitorCalls())
func (mock *NewMonitorDepsMock) NewNodeMonitorCalls() []struct {
	Client Client
} {
	var calls []struct {
		Client Client
	}
	mock.lockNewNodeMonitor.RLock()
	calls = mock.calls.NewNodeMonitor
	mock.lockNewNodeMonitor.RUnlock()
	return calls
}

// PrivateKeyFile calls PrivateKeyFileFunc.
func (mock *NewMonitorDepsMock) PrivateKeyFile(filename string) opcua.Option {
	if mock.PrivateKeyFileFunc == nil {
		panic("NewMonitorDepsMock.PrivateKeyFileFunc: method is nil but NewMonitorDeps.PrivateKeyFile was just called")
	}
	callInfo := struct {
		Filename string
	}{
		Filename: filename,
	}
	mock.lockPrivateKeyFile.Lock()
	mock.calls.PrivateKeyFile = append(mock.calls.PrivateKeyFile, callInfo)
	mock.lockPrivateKeyFile.Unlock()
	return mock.PrivateKeyFileFunc(filename)
}

// PrivateKeyFileCalls gets all the calls that were made to PrivateKeyFile.
// Check the length with:
//     len(mockedNewMonitorDeps.PrivateKeyFileCalls())
func (mock *NewMonitorDepsMock) PrivateKeyFileCalls() []struct {
	Filename string
} {
	var calls []struct {
		Filename string
	}
	mock.lockPrivateKeyFile.RLock()
	calls = mock.calls.PrivateKeyFile
	mock.lockPrivateKeyFile.RUnlock()
	return calls
}

// SecurityFromEndpoint calls SecurityFromEndpointFunc.
func (mock *NewMonitorDepsMock) SecurityFromEndpoint(ep *ua.EndpointDescription, authType ua.UserTokenType) opcua.Option {
	if mock.SecurityFromEndpointFunc == nil {
		panic("NewMonitorDepsMock.SecurityFromEndpointFunc: method is nil but NewMonitorDeps.SecurityFromEndpoint was just called")
	}
	callInfo := struct {
		Ep       *ua.EndpointDescription
		AuthType ua.UserTokenType
	}{
		Ep:       ep,
		AuthType: authType,
	}
	mock.lockSecurityFromEndpoint.Lock()
	mock.calls.SecurityFromEndpoint = append(mock.calls.SecurityFromEndpoint, callInfo)
	mock.lockSecurityFromEndpoint.Unlock()
	return mock.SecurityFromEndpointFunc(ep, authType)
}

// SecurityFromEndpointCalls gets all the calls that were made to SecurityFromEndpoint.
// Check the length with:
//     len(mockedNewMonitorDeps.SecurityFromEndpointCalls())
func (mock *NewMonitorDepsMock) SecurityFromEndpointCalls() []struct {
	Ep       *ua.EndpointDescription
	AuthType ua.UserTokenType
} {
	var calls []struct {
		Ep       *ua.EndpointDescription
		AuthType ua.UserTokenType
	}
	mock.lockSecurityFromEndpoint.RLock()
	calls = mock.calls.SecurityFromEndpoint
	mock.lockSecurityFromEndpoint.RUnlock()
	return calls
}

// SelectEndpoint calls SelectEndpointFunc.
func (mock *NewMonitorDepsMock) SelectEndpoint(endpoints []*ua.EndpointDescription, policy string, mode ua.MessageSecurityMode) *ua.EndpointDescription {
	if mock.SelectEndpointFunc == nil {
		panic("NewMonitorDepsMock.SelectEndpointFunc: method is nil but NewMonitorDeps.SelectEndpoint was just called")
	}
	callInfo := struct {
		Endpoints []*ua.EndpointDescription
		Policy    string
		Mode      ua.MessageSecurityMode
	}{
		Endpoints: endpoints,
		Policy:    policy,
		Mode:      mode,
	}
	mock.lockSelectEndpoint.Lock()
	mock.calls.SelectEndpoint = append(mock.calls.SelectEndpoint, callInfo)
	mock.lockSelectEndpoint.Unlock()
	return mock.SelectEndpointFunc(endpoints, policy, mode)
}

// SelectEndpointCalls gets all the calls that were made to SelectEndpoint.
// Check the length with:
//     len(mockedNewMonitorDeps.SelectEndpointCalls())
func (mock *NewMonitorDepsMock) SelectEndpointCalls() []struct {
	Endpoints []*ua.EndpointDescription
	Policy    string
	Mode      ua.MessageSecurityMode
} {
	var calls []struct {
		Endpoints []*ua.EndpointDescription
		Policy    string
		Mode      ua.MessageSecurityMode
	}
	mock.lockSelectEndpoint.RLock()
	calls = mock.calls.SelectEndpoint
	mock.lockSelectEndpoint.RUnlock()
	return calls
}

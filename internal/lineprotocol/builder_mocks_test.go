// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package lineprotocol

import (
	lp "github.com/influxdata/line-protocol/v2/lineprotocol"
	"sync"
	"time"
)

// Ensure, that PoolerMock does implement Pooler.
// If this is not the case, regenerate this file with moq.
var _ Pooler = &PoolerMock{}

// PoolerMock is a mock implementation of Pooler.
//
//	func TestSomethingThatUsesPooler(t *testing.T) {
//
//		// make and configure a mocked Pooler
//		mockedPooler := &PoolerMock{
//			GetFunc: func() any {
//				panic("mock out the Get method")
//			},
//			PutFunc: func(x any)  {
//				panic("mock out the Put method")
//			},
//		}
//
//		// use mockedPooler in code that requires Pooler
//		// and then make assertions.
//
//	}
type PoolerMock struct {
	// GetFunc mocks the Get method.
	GetFunc func() any

	// PutFunc mocks the Put method.
	PutFunc func(x any)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// X is the x argument value.
			X any
		}
	}
	lockGet sync.RWMutex
	lockPut sync.RWMutex
}

// Get calls GetFunc.
func (mock *PoolerMock) Get() any {
	if mock.GetFunc == nil {
		panic("PoolerMock.GetFunc: method is nil but Pooler.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedPooler.GetCalls())
func (mock *PoolerMock) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Put calls PutFunc.
func (mock *PoolerMock) Put(x any) {
	if mock.PutFunc == nil {
		panic("PoolerMock.PutFunc: method is nil but Pooler.Put was just called")
	}
	callInfo := struct {
		X any
	}{
		X: x,
	}
	mock.lockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	mock.lockPut.Unlock()
	mock.PutFunc(x)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//
//	len(mockedPooler.PutCalls())
func (mock *PoolerMock) PutCalls() []struct {
	X any
} {
	var calls []struct {
		X any
	}
	mock.lockPut.RLock()
	calls = mock.calls.Put
	mock.lockPut.RUnlock()
	return calls
}

// Ensure, that EncoderMock does implement Encoder.
// If this is not the case, regenerate this file with moq.
var _ Encoder = &EncoderMock{}

// EncoderMock is a mock implementation of Encoder.
//
//	func TestSomethingThatUsesEncoder(t *testing.T) {
//
//		// make and configure a mocked Encoder
//		mockedEncoder := &EncoderMock{
//			AddFieldFunc: func(key string, value lp.Value)  {
//				panic("mock out the AddField method")
//			},
//			AddTagFunc: func(key string, value string)  {
//				panic("mock out the AddTag method")
//			},
//			BytesFunc: func() []byte {
//				panic("mock out the Bytes method")
//			},
//			EndLineFunc: func(t time.Time)  {
//				panic("mock out the EndLine method")
//			},
//			ErrFunc: func() error {
//				panic("mock out the Err method")
//			},
//			ResetFunc: func()  {
//				panic("mock out the Reset method")
//			},
//			StartLineFunc: func(measurement string)  {
//				panic("mock out the StartLine method")
//			},
//		}
//
//		// use mockedEncoder in code that requires Encoder
//		// and then make assertions.
//
//	}
type EncoderMock struct {
	// AddFieldFunc mocks the AddField method.
	AddFieldFunc func(key string, value lp.Value)

	// AddTagFunc mocks the AddTag method.
	AddTagFunc func(key string, value string)

	// BytesFunc mocks the Bytes method.
	BytesFunc func() []byte

	// EndLineFunc mocks the EndLine method.
	EndLineFunc func(t time.Time)

	// ErrFunc mocks the Err method.
	ErrFunc func() error

	// ResetFunc mocks the Reset method.
	ResetFunc func()

	// StartLineFunc mocks the StartLine method.
	StartLineFunc func(measurement string)

	// calls tracks calls to the methods.
	calls struct {
		// AddField holds details about calls to the AddField method.
		AddField []struct {
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value lp.Value
		}
		// AddTag holds details about calls to the AddTag method.
		AddTag []struct {
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value string
		}
		// Bytes holds details about calls to the Bytes method.
		Bytes []struct {
		}
		// EndLine holds details about calls to the EndLine method.
		EndLine []struct {
			// T is the t argument value.
			T time.Time
		}
		// Err holds details about calls to the Err method.
		Err []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
		}
		// StartLine holds details about calls to the StartLine method.
		StartLine []struct {
			// Measurement is the measurement argument value.
			Measurement string
		}
	}
	lockAddField  sync.RWMutex
	lockAddTag    sync.RWMutex
	lockBytes     sync.RWMutex
	lockEndLine   sync.RWMutex
	lockErr       sync.RWMutex
	lockReset     sync.RWMutex
	lockStartLine sync.RWMutex
}

// AddField calls AddFieldFunc.
func (mock *EncoderMock) AddField(key string, value lp.Value) {
	if mock.AddFieldFunc == nil {
		panic("EncoderMock.AddFieldFunc: method is nil but Encoder.AddField was just called")
	}
	callInfo := struct {
		Key   string
		Value lp.Value
	}{
		Key:   key,
		Value: value,
	}
	mock.lockAddField.Lock()
	mock.calls.AddField = append(mock.calls.AddField, callInfo)
	mock.lockAddField.Unlock()
	mock.AddFieldFunc(key, value)
}

// AddFieldCalls gets all the calls that were made to AddField.
// Check the length with:
//
//	len(mockedEncoder.AddFieldCalls())
func (mock *EncoderMock) AddFieldCalls() []struct {
	Key   string
	Value lp.Value
} {
	var calls []struct {
		Key   string
		Value lp.Value
	}
	mock.lockAddField.RLock()
	calls = mock.calls.AddField
	mock.lockAddField.RUnlock()
	return calls
}

// AddTag calls AddTagFunc.
func (mock *EncoderMock) AddTag(key string, value string) {
	if mock.AddTagFunc == nil {
		panic("EncoderMock.AddTagFunc: method is nil but Encoder.AddTag was just called")
	}
	callInfo := struct {
		Key   string
		Value string
	}{
		Key:   key,
		Value: value,
	}
	mock.lockAddTag.Lock()
	mock.calls.AddTag = append(mock.calls.AddTag, callInfo)
	mock.lockAddTag.Unlock()
	mock.AddTagFunc(key, value)
}

// AddTagCalls gets all the calls that were made to AddTag.
// Check the length with:
//
//	len(mockedEncoder.AddTagCalls())
func (mock *EncoderMock) AddTagCalls() []struct {
	Key   string
	Value string
} {
	var calls []struct {
		Key   string
		Value string
	}
	mock.lockAddTag.RLock()
	calls = mock.calls.AddTag
	mock.lockAddTag.RUnlock()
	return calls
}

// Bytes calls BytesFunc.
func (mock *EncoderMock) Bytes() []byte {
	if mock.BytesFunc == nil {
		panic("EncoderMock.BytesFunc: method is nil but Encoder.Bytes was just called")
	}
	callInfo := struct {
	}{}
	mock.lockBytes.Lock()
	mock.calls.Bytes = append(mock.calls.Bytes, callInfo)
	mock.lockBytes.Unlock()
	return mock.BytesFunc()
}

// BytesCalls gets all the calls that were made to Bytes.
// Check the length with:
//
//	len(mockedEncoder.BytesCalls())
func (mock *EncoderMock) BytesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockBytes.RLock()
	calls = mock.calls.Bytes
	mock.lockBytes.RUnlock()
	return calls
}

// EndLine calls EndLineFunc.
func (mock *EncoderMock) EndLine(t time.Time) {
	if mock.EndLineFunc == nil {
		panic("EncoderMock.EndLineFunc: method is nil but Encoder.EndLine was just called")
	}
	callInfo := struct {
		T time.Time
	}{
		T: t,
	}
	mock.lockEndLine.Lock()
	mock.calls.EndLine = append(mock.calls.EndLine, callInfo)
	mock.lockEndLine.Unlock()
	mock.EndLineFunc(t)
}

// EndLineCalls gets all the calls that were made to EndLine.
// Check the length with:
//
//	len(mockedEncoder.EndLineCalls())
func (mock *EncoderMock) EndLineCalls() []struct {
	T time.Time
} {
	var calls []struct {
		T time.Time
	}
	mock.lockEndLine.RLock()
	calls = mock.calls.EndLine
	mock.lockEndLine.RUnlock()
	return calls
}

// Err calls ErrFunc.
func (mock *EncoderMock) Err() error {
	if mock.ErrFunc == nil {
		panic("EncoderMock.ErrFunc: method is nil but Encoder.Err was just called")
	}
	callInfo := struct {
	}{}
	mock.lockErr.Lock()
	mock.calls.Err = append(mock.calls.Err, callInfo)
	mock.lockErr.Unlock()
	return mock.ErrFunc()
}

// ErrCalls gets all the calls that were made to Err.
// Check the length with:
//
//	len(mockedEncoder.ErrCalls())
func (mock *EncoderMock) ErrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockErr.RLock()
	calls = mock.calls.Err
	mock.lockErr.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *EncoderMock) Reset() {
	if mock.ResetFunc == nil {
		panic("EncoderMock.ResetFunc: method is nil but Encoder.Reset was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	mock.lockReset.Unlock()
	mock.ResetFunc()
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//
//	len(mockedEncoder.ResetCalls())
func (mock *EncoderMock) ResetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReset.RLock()
	calls = mock.calls.Reset
	mock.lockReset.RUnlock()
	return calls
}

// StartLine calls StartLineFunc.
func (mock *EncoderMock) StartLine(measurement string) {
	if mock.StartLineFunc == nil {
		panic("EncoderMock.StartLineFunc: method is nil but Encoder.StartLine was just called")
	}
	callInfo := struct {
		Measurement string
	}{
		Measurement: measurement,
	}
	mock.lockStartLine.Lock()
	mock.calls.StartLine = append(mock.calls.StartLine, callInfo)
	mock.lockStartLine.Unlock()
	mock.StartLineFunc(measurement)
}

// StartLineCalls gets all the calls that were made to StartLine.
// Check the length with:
//
//	len(mockedEncoder.StartLineCalls())
func (mock *EncoderMock) StartLineCalls() []struct {
	Measurement string
} {
	var calls []struct {
		Measurement string
	}
	mock.lockStartLine.RLock()
	calls = mock.calls.StartLine
	mock.lockStartLine.RUnlock()
	return calls
}
